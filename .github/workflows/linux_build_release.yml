name: Release Linux build

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-linux:
    name: Build & Release Linux
    runs-on: ubuntu-latest

    env:
      VCPKG_ROOT: ${{ github.workspace }}/vcpkg
      VCPKG_DEFAULT_TRIPLET: x64-linux-dynamic
      CC: clang
      CXX: clang++

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install system dependencies (Qt6 GUI)
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential clang lld cmake ninja-build pkg-config \
            autoconf automake autoconf-archive libtool libltdl-dev python3 python3-pip \
            curl git unzip zip libx11-dev libx11-xcb-dev libxext-dev libxfixes-dev libxi-dev \
            libxrender-dev libxrandr-dev libxcursor-dev libxinerama-dev libxss-dev \
            libxkbcommon-dev libxkbcommon-x11-dev libxcb1-dev libxcb-keysyms1-dev \
            libxcb-image0-dev libxcb-shm0-dev libxcb-icccm4-dev libxcb-sync-dev \
            libxcb-xfixes0-dev libxcb-shape0-dev libxcb-randr0-dev libxcb-render0-dev \
            libxcb-render-util0-dev libxcb-util-dev libxcb-xinput-dev libxcb-cursor-dev \
            libxcb-glx0-dev libxcb-xkb-dev libxcb-xinerama0-dev libxcb-damage0-dev \
            libxcb-composite0-dev libgtk-3-dev libsm-dev libice-dev libpthread-stubs0-dev \
            libwayland-dev libwayland-egl-backend-dev libgl1-mesa-dev libegl1-mesa-dev \
            libgles2-mesa-dev mesa-common-dev libglu1-mesa-dev libfontconfig1-dev \
            libfreetype6-dev libharfbuzz-dev libicu-dev libdbus-1-dev libatspi2.0-dev \
            libinput-dev libmtdev-dev libevdev-dev libts-dev libudev-dev libvulkan-dev \
            libjpeg-dev libpng-dev libtiff-dev libgif-dev libwebp-dev libavif-dev \
            libdouble-conversion-dev libmd4c-dev libb2-dev libproxy-dev zlib1g-dev libssl-dev \
            libmd4c-dev libmd4c-html0

      - name: Setup CMake
        uses: lukka/get-cmake@latest
        with:
          cmake-version: "3.31.0"

      - name: Ensure vcpkg exists (clone if missing)
        run: |
          if [ -d "${VCPKG_ROOT}/.git" ]; then
            echo "vcpkg already exists, skipping clone"
          else
            git clone https://github.com/microsoft/vcpkg.git "$VCPKG_ROOT"
            "$VCPKG_ROOT/bootstrap-vcpkg.sh"
          fi

      - name: Write overlay triplet (vcpkg-triplets/x64-linux-dynamic.cmake)
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/vcpkg-triplets"
          cat > "${GITHUB_WORKSPACE}/vcpkg-triplets/x64-linux-dynamic.cmake" <<'EOF'
          # Overlay triplet to request dynamic linkage
          set(VCPKG_TARGET_ARCHITECTURE x64)
          set(VCPKG_CRT_LINKAGE dynamic)
          set(VCPKG_LIBRARY_LINKAGE dynamic)
          set(VCPKG_CMAKE_SYSTEM_NAME Linux)

          # Hint to Qt port - not guaranteed but helpful
          set(QT_FEATURE_shared ON CACHE BOOL "")
          set(QT_FEATURE_static OFF CACHE BOOL "")
          EOF
          echo "Wrote overlay triplet to vcpkg-triplets/x64-linux-dynamic.cmake"

      - name: (Optional) Force clean qt buildtrees/packages to ensure rebuild
        run: |
          # Remove old partial builds / installed triplet to force fresh shared build
          rm -rf "${VCPKG_ROOT}/buildtrees/qt"* "${VCPKG_ROOT}/packages/qtbase"* || true
          rm -rf "${VCPKG_ROOT}_installed/${{ env.VCPKG_DEFAULT_TRIPLET }}" || true
          ls -la "${VCPKG_ROOT}" || true

      - name: Install dependencies via vcpkg (request dynamic)
        run: |
          # Do not use --clean-after-build during debugging â€” add later if desired
          "$VCPKG_ROOT/vcpkg" install --triplet "${{ env.VCPKG_DEFAULT_TRIPLET }}" \
            --overlay-triplets="$GITHUB_WORKSPACE/vcpkg-triplets" || (echo "vcpkg install failed" && exit 1)
        env:
          VCPKG_FEATURE_FLAGS: manifests
          VCPKG_LIBRARY_LINKAGE: dynamic
          VCPKG_BUILD_TYPE: release
          VCPKG_PREFER_SYSTEM_LIBS: 0
          CC: clang
          CXX: clang++

      - name: Debug vcpkg results (find .so / plugins)
        run: |
          echo "=== vcpkg root ==="
          ls -la "${VCPKG_ROOT}" || true
          echo "=== vcpkg_installed root (${VCPKG_ROOT}_installed) ==="
          ls -la "${VCPKG_ROOT}_installed" || true
          echo "--- installed triplet directories ---"
          ls -la "${VCPKG_ROOT}_installed/${{ env.VCPKG_DEFAULT_TRIPLET }}" || true
          echo "=== find libQt6*.so under vcpkg_installed ==="
          find "${VCPKG_ROOT}_installed" -type f -name "libQt6*.so*" -print || true
          echo "=== find Qt plugins under vcpkg_installed ==="
          find "${VCPKG_ROOT}_installed" -type d -path "*/plugins/*" -print || true
          echo "=== also search packages/ for artifacts (debug) ==="
          find "${VCPKG_ROOT}/packages" -type f -name "libQt6*.so*" -print || true

      - name: Configure and build project
        run: |
          cmake -B build -S . \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake \
            -DCMAKE_POLICY_DEFAULT_CMP0177=NEW \
            -G Ninja
          cmake --build build --config Release

      - name: Extract project version from CMakeLists.txt
        id: get_version
        run: |
          VERSION=$(grep -Po '(?<=VERSION )\d+\.\d+\.\d+' CMakeLists.txt || echo "0.0.0")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Debug binary and installed libs before bundling
        run: |
          echo "Built binaries (repo root / bin and build/):"
          ls -la ./bin || true
          ls -la ./build || true
          echo "Look for app binary:"
          if [ -f "./bin/Notesman" ]; then echo "Found ./bin/Notesman"; else echo "No ./bin/Notesman"; fi
          echo ""
          echo "vcpkg_installed libs for triplet:"
          ls -la "${VCPKG_ROOT}_installed/${{ env.VCPKG_DEFAULT_TRIPLET }}/lib" || true
          ls -la "${VCPKG_ROOT}_installed/${{ env.VCPKG_DEFAULT_TRIPLET }}/debug" || true

      - name: Bundle Qt runtime libraries (copy from vcpkg_installed)
        run: |
          mkdir -p dist
          # copy binary from bin (project sets RUNTIME_OUTPUT_DIRECTORY to bin)
          if [ -f "./bin/Notesman" ]; then
            cp ./bin/Notesman dist/
          else
            echo "ERROR: ./bin/Notesman not found" >&2
            ls -la ./bin || true
            exit 1
          fi

          # Copy Qt shared libs from vcpkg_installed
          INSTALLED_LIB_DIR="${VCPKG_ROOT}_installed/${{ env.VCPKG_DEFAULT_TRIPLET }}/lib"
          if [ -d "$INSTALLED_LIB_DIR" ]; then
            QT_LIBS=$(find "$INSTALLED_LIB_DIR" -name "libQt6*.so*" 2>/dev/null || true)
          else
            QT_LIBS=""
          fi

          # fallback: check packages (some builds put artefacts there)
          if [ -z "$QT_LIBS" ]; then
            QT_LIBS=$(find "${VCPKG_ROOT}/packages" -name "libQt6*.so*" 2>/dev/null || true)
          fi

          if [ -n "$QT_LIBS" ]; then
            echo "Copying Qt shared libs:"
            echo "$QT_LIBS"
            cp -v $QT_LIBS dist/ || true
          else
            echo "No Qt .so files found to copy (shared build likely not produced)." >&2
            echo "See debug output earlier. Aborting bundling." >&2
            exit 1
          fi

          # Copy plugins if present
          QT_PLUGINS_DIR="${VCPKG_ROOT}_installed/${{ env.VCPKG_DEFAULT_TRIPLET }}/plugins"
          if [ -d "$QT_PLUGINS_DIR" ]; then
            cp -vr "$QT_PLUGINS_DIR" dist/ || true
          fi

          # copy platform plugin specifically if present (libqxcb.so)
          if [ -f "${QT_PLUGINS_DIR}/platforms/libqxcb.so" ]; then
            mkdir -p dist/platforms
            cp -v "${QT_PLUGINS_DIR}/platforms/libqxcb.so" dist/platforms/
          fi

          # archive
          tar -czf notesman-linux-${{ steps.get_version.outputs.version }}.tar.gz -C dist .

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.get_version.outputs.version }}
          name: Notesman v${{ steps.get_version.outputs.version }}
          body: "Automated release for Notesman v${{ steps.get_version.outputs.version }}."
          files: notesman-linux-${{ steps.get_version.outputs.version }}.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
